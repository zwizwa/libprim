(define (expand-quasiquote l)
  (letrec
      ((mcons
        (lambda (f l r)
          (if (and (pair? r)
                   (eq? (car r) 'quote)
                   (eq? (car (cdr r)) (cdr f))
                   (pair? l)
                   (eq? (car l) 'quote)
                   (eq? (car (cdr l)) (car f)))
              (if (or (procedure? f) (number? f) (string? f))
                  f (list 'quote f))
              ;(if (eqv? l vector)
              ;    (apply l (eval r))
                  (list 'cons l r)
                  )))
       (mappend
        (lambda (f l r)
          (if (or (null? (cdr f))
                  (and (pair? r)
                       (eq? (car r) 'quote)
                       (eq? (car (cdr r)) '())))
              l (list 'append l r))))
       (tx
        (lambda (level form)
          (cond ((not (pair? form))
                 (if (or (procedure? form) (number? form) (string? form))
                     form (list 'quote form)))
                ((eq? 'quasiquote (car form))
                 (mcons form ''quasiquote (tx (+ level 1) (cdr form))))
                (#t (if (zero? level)
                        (cond ((eq? (car form) 'unquote) (car (cdr form)))
                              ((eq? (car form) 'unquote-splicing)
                               (error "Unquote-splicing wasn't in a list" form))
                              ((and (pair? (car form))
                                    (eq? (car (car form)) 'unquote-splicing))
                               (mappend form (car (cdr (car form)))
                                        (tx level (cdr form))))
                              (#t (mcons form (tx level (car form))
                                         (tx level (cdr form)))))
                        (cond ((eq? (car form) 'unquote)
                               (mcons form ''unquote (tx (- level 1) (cdr form))))
                              ((eq? (car form) 'unquote-splicing)
                               (mcons form ''unquote-splicing
                                      (tx (- level 1) (cdr form))))
                              (#t (mcons form (tx level (car form))
                                         (tx level (cdr form)))))))))))
    (tx 0 (car (cdr l)))))


(define (expand-cond form)
  (let next ((clauses (cdr form)))
    (if (null? clauses) '(void)
        (let* ((clause (car clauses))
               (rest (lambda () (next (cdr clauses))))
               (guard (car clause))
               (body (cons 'begin (cdr clause))))
          (cond
           ((eq? 'else guard) body)
           ((null? (cdr clause))
            `(if ,guard ,(void) ,(rest)))
           ((eq? '=> (cadr clause))
            (let ((body (caddr clause)))
              `(let ((bv ,guard))
                 (if bv (,body bv) ,(rest)))))
           (else
            `(if ,guard ,body ,(rest))))))))
