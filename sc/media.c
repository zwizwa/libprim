/* libprim/media bindings for Scheme

   This file bridges the Scheme memory / control (exception) model
   with low-level C objects.  The function prototypes are mined to
   produce media.h_sc_prims contating media_table_init + macro defs.

   FIXME: 
     * this file should be autogenerated from the media/.h C objects. 
     * extend leaf objects with error handling mechanism

 */

#include "scheme.h"
#include <media/ffmpeg.h>
#include <leaf/bytes.h>
#include "media.h_sc_prims"
#include <media/xwindow.h>
#include <media/xv.h>
#include <media/glx.h>
#include <leaf/grid.h>


/* Instead of storing the class object in the ex struct (see
   DEF_AREF_TYPE and ex's base_types member), it's also possible to
   store it in a global variable.  Here we use a _c postfix naming
   convention. */

#define DEF_TYPE(name) \
    static inline name *object_to_##name(object ob, ex *m) { \
        return (name*)object_aref_struct(ob,m,name##_type()); }

DEF_TYPE(codec)
DEF_TYPE(codec_context)
DEF_TYPE(vframe)
DEF_TYPE(aframe)

static prim_def media_prims[] = media_table_init;

void _sc_media_init(sc *sc) {
    av_register_all();
    _sc_def_prims(sc, media_prims);
}



/*** FFMPEG ***/

_ sc_make_codec(sc* sc, _ spec) {
    char *name = CAST(cstring, spec);
    codec *c = codec_new(name);
    if (!c) return ERROR("codec-not-found", spec);
    return _sc_make_aref(sc, (leaf_object*)codec_new(name));
}

_ sc_make_codec_context(sc *sc) {
    return _sc_make_aref(sc, (leaf_object *)codec_context_new());
}


_ sc_codec_context_info(sc *sc, _ ob) {
    codec_context *c = CAST(codec_context, ob);
    codec_context_info(c, _sc_port(sc));
    return VOID;
}

_ sc_make_vframe(sc *sc, _ ob) {
    codec_context *c = CAST(codec_context, ob);
    vframe *f = vframe_new(c);
    return _sc_make_aref(sc, (leaf_object *)f);
}

_ sc_make_aframe(sc *sc, _ ob) {
    codec_context *c = CAST(codec_context, ob);
    aframe *f = aframe_new(c);
    if (!f) return INVALID(ob);
    return _sc_make_aref(sc, (leaf_object*)f);
}

_ sc_bang_frame_test(sc *sc, _ ob_frame, _ ob_ctx, _ ob_int) {
    int i = CAST_INTEGER(ob_int);
    vframe *f = CAST(vframe, ob_frame);
    codec_context *c = CAST(codec_context, ob_ctx);
    frame_test(f, c, i);
    return VOID;
}

/* As/dissociate codec context to codec. */
_ sc_codec_context_open(sc *sc, _ ctx, _ cod) {
    if (codec_context_open(CAST(codec_context, ctx), CAST(codec, cod)) < 0) {
        ERROR("invalid-context", cod);
    }
    return VOID;
}
_ sc_codec_context_close(sc *sc, _ ctx) {
    if (codec_context_close(CAST(codec_context, ctx)) < 0) {
        return ERROR("invalid-context", ctx);
    }
    return VOID;
}

_ sc_codec_to_string(sc *sc, _ ob) {
    codec *c = CAST(codec, ob);
    return _sc_make_string(sc, c->codec->name);
}

_ sc_codec_context_encode_video(sc *sc, _ ctx, _ frm, _ buf) {
    vframe *f = (frm == FALSE) ? NULL : CAST(vframe, frm); // delayed frames
    codec_context_encode_video(CAST(codec_context, ctx), f, CAST(bytes, buf));
    return VOID;
}

_ sc_codec_context_encode_audio(sc *sc, _ ctx, _ frm, _ buf) {
    aframe *f = (frm == FALSE) ? NULL : CAST(aframe, frm); // delayed frames
    codec_context_encode_audio(CAST(codec_context, ctx), f, CAST(bytes, buf));
    return VOID;
}


/*** X11 ***/

DEF_TYPE(xwindow)
DEF_TYPE(xdisplay)
DEF_TYPE(grid)
DEF_TYPE(grid_proc)

_ sc_make_display(sc *sc, _ ob) {
    return _sc_make_aref(sc, xdisplay_new(CAST(cstring, ob)));
}
_ sc_make_window(sc *sc) {
    return _sc_make_aref(sc, xwindow_new());
}
_ sc_window_config(sc *sc, _ win, _ disp) {
    xwindow_config(CAST(xwindow, win), CAST(xdisplay, disp));
    return VOID;
}


/*** GRID ***/

_ sc_make_grid_1(sc *sc, _ len, _ init) {
    return _sc_make_aref(sc, grid_new_1(CAST_INTEGER(len), CAST(inexact, init)->value));
}

_ sc_grid_for_each(sc *sc, _ fn, _ gridv) {
    vector *v = CAST(vector, gridv);
    grid_proc *p = CAST(grid_proc, fn);
    int i, argc = vector_size(v);
    grid *argv[argc];
    for (i=0; i<argc; i++) argv[i] = CAST(grid, v->slot[i]);
    if (grid_for_each(p, argc, argv)) ERROR("args", CONS(fn, CONS(gridv, NIL)));
    return VOID;
}

static void _add(grid_atom *a, grid_atom *b, grid_atom *c) { *c = *a + *b; }
static void _sub(grid_atom *a, grid_atom *b, grid_atom *c) { *c = *a - *b; }
static void _mul(grid_atom *a, grid_atom *b, grid_atom *c) { *c = (*a) * (*b); }

_ grid_proc_wrap(sc *sc, void *fn, int argc) { 
    grid_proc *g = grid_proc_new(fn, argc);
    return _sc_make_aref(sc, g);
}

#define PROC(fn, nargs) return grid_proc_wrap(sc, fn, nargs);
_ sc_grid_proc_add(sc *sc) { PROC(_add, 3); }
_ sc_grid_proc_sub(sc *sc) { PROC(_sub, 3); }
_ sc_grid_proc_mul(sc *sc) { PROC(_mul, 3); }


_ sc_grid_dump(sc *sc, _ g, _ p) { 
    grid_dump(CAST(grid, g), CAST(port, p));  return VOID; 
}

_ sc_grid_to_vector(sc *sc, _ ob) {
    grid *g = CAST(grid, ob);
    int i, nb = grid_total(g);
    vector *v = gc_alloc(EX->gc, nb);
    for (i=0; i<nb; i++) {
        v->slot[i] = INEXACT(g->buf[i]);
    }
    return vector_to_object(v);
}
_ sc_grid_ref(sc *sc, _ obg, _ obi) {
    int i = CAST_INTEGER(obi);
    grid *g = CAST(grid, obg);
    int nb = grid_total(g);
    if ((i < 0) || (i >= nb)) ERROR("inval", obi);
    return INEXACT(g->buf[i]);
}
_ sc_bang_grid_set(sc *sc, _ obg, _ obi, _ obv) {
    int i = CAST_INTEGER(obi);
    grid *g = CAST(grid, obg);
    int nb = grid_total(g);
    if ((i < 0) || (i >= nb)) ERROR("inval", obi);
    g->buf[i] = CAST(inexact, obv)->value;
    return VOID;
}
_ sc_grid_dims(sc *sc, _ obg) {
    grid *g = CAST(grid, obg);
    vector *v = gc_alloc(EX->gc, GRID_MAX_DIMS);
    int i;
    for (i=0; i<GRID_MAX_DIMS; i++) {
        v->slot[i] = NUMBER(g->dim[i]);
    }
    return vector_to_object(v);
}
