# -*- makefile -*-



CPPFLAGS += -I../ -DTASK_DEBUG=0
# Note that GCC needs "-x c" if you don't use a ".c" extension.
CFLAGS += -x c
COMPILE = $(CC) $(CPPFLAGS) $(CFLAGS) $(OPTI_CFLAGS) $(DEBUG_CFLAGS) 

APP_LDFLAGS += 
# APP_DEBUG_LDFLAGS += -lefence -lpthread

# This is for testing compliance; don't set this in archived code.

# CC = gcc -ansi -pedantic  	# this is quite restrictive and doesnt work yet
# CC = gcc -std=c99 -pedantic	# seems to compile with some warnings

# Make deps from .c file.  This needs the .h_* files before it can
# parse, so we make those deps explicit.

%.d: %.c Makefile $(GEN)
	set -e; rm -f $@; \
		$(CC) -M $(CPPFLAGS) $< > $@.$$$$; \
		sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@; \
		rm -f $@.$$$$

-include $(SRC:.c=.d)

%.o: %.c Makefile
	$(COMPILE) -o $@ -c $<

$(APP): $(OBJ) $(DEP_OBJ)
	$(CC) -o $(APP) $(APP_DEBUG_LDFLAGS) $(OBJ) $(DEP_OBJ) $(LIBS) $(APP_LDFLAGS) $(LDFLAGS)

$(TEST): $(TEST_OBJ)
	$(CC) -o test $(TEST_OBJ)

run_test: $(TEST)
	./$(TEST)

# Target to generate header files.  It is actually the deps for .d
# that generate them, so here we just remove the .d files to get a
# clean tree.

.PHONY: gen
gen: $(GEN)
	rm -f *.d

# The `clean' target leaves the generated files intact.  Distribution
# tarball is independent of mzscheme code generation.
JUNK=*.o *.d *.d.* *.a *~ */*~ *.class *.so
.PHONY: clean
clean:
	rm -f $(JUNK) $(APP) $(TEST)

# The `mrproper' target also cleans the generated files.
mrproper: clean
	rm -rf *.h_* *.c_*
