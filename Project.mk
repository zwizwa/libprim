
# Non-recursive make.  See:
#  [1] http://miller.emu.id.au/pmiller/books/rmch/
#  [2] http://www.xs4all.nl/~evbergen/nonrecursive-make.html
#  [3] http://make.mad-scientist.us/multi-arch.html

# The key point in making decent GNU makefiles seems to be
# understanding how substitution works; i.e. when exactly computations
# happen.  Original make was fully lazy functional, but GNU make has
# some strict (imperative) features that are useful as a macro
# facility.

# The whole project tree is managed by a single make session,
# constructed using file inclusion and the imperative (strict)
# features of make: assignment using ":=" instead of "=".  See section
# 5.2 in [1].

# To support separate build dirs, we use VPATH.

# Defines generated by the configure script.
# Makefile.defs: configure
#	./configure
include Makefile.defs

all: _all

MODULES := leaf ex sc


CFLAGS += $(pathsubst %, -I%, $(MODULES))

# Make sure the entire build depends on all makefile fragments.
MAKEFILES := Project.mk $(pathsubst %, %/module.mk, $(MODULES))
# MAKEFILES = Project.mk

%.d: %.c $(MAKEFILES)
	@echo "$@"
	@( echo -n "`dirname $<`/"; $(CC) -M -MG $(CPPFLAGS) $< ) > $@


%.o: %.c $(MAKEFILES)
	@echo "$@"
	@$(CC) $(CPPFLAGS) $(CFLAGS) -o $@ -c $<

# Generated header files.  These assume the .c file's directory
# contains the `gen_prims.ss' script.
%.h_prims: %.c
	@echo "$@"
	@$(MZSCHEME) `dirname $<`/gen_prims.ss $< >$@


# This function generates a makefile fragment that gathers variables
# and build rules through an include, and accumulates them to global
# variables.
define module_fragment
MODULE := $(1) 		# Define module name for use in included fragment
include $(1)/module.mk  # Include module fragment

# Get properly prefixed list of sources and objects.
$(1)_SRC := $$(patsubst %, $(1)/%, $$(SRC))
$(1)_OBJ := $$($(1)_SRC:.c=.o)
PROJECT_SRC := $$(PROJECT_SRC) $$($(1)_SRC)
# Build a single archive per module.
$(1)/$(1).a: $$($(1)_OBJ)
	@echo "$$@"
	@ar rcs $$@ $$($(1)_OBJ)
PROJECT_A := $$(PROJECT_A) $(1)/$(1).a
# debug print
# DUMMY := $$(shell echo $(1) : $$($(1)_SRC) >&2)

# Clear local vars.
SRC :=
MODULE :=

endef

# Expand the template for each module
$(foreach prog,$(MODULES),$(eval $(call module_fragment,$(prog))))

# Include generated dependencies.
-include $(PROJECT_SRC:.c=.d)

.PHONY: all clean

# OBJECTS := $(PROJECT_SRC:.c=.o)
OBJECTS := $(PROJECT_A)

_all: $(OBJECTS)

