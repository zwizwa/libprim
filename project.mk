
# Non-recursive make.  See:
#  [1] http://miller.emu.id.au/pmiller/books/rmch/
#  [2] http://www.xs4all.nl/~evbergen/nonrecursive-make.html
#  [3] http://make.mad-scientist.us/multi-arch.html

# The key point in making decent GNU makefiles seems to be
# understanding how substitution works; i.e. when exactly computations
# happen.  Original make was fully lazy functional, but GNU make has
# some strict (imperative) features that are useful as a macro
# facility.

# The whole project tree is managed by a single make session,
# constructed using file inclusion and the imperative (strict)
# features of make: assignment using ":=" instead of "=".  See section
# 5.2 in [1].

# To support separate build dirs, we use VPATH.

# Defines generated by the configure script.
# Makefile.defs: configure
#	./configure
include Makefile.defs

all: _all

MODULES := leaf ex sc pf

VOID := $(shell mkdir -p $(MODULES))

CFLAGS += $(pathsubst %, -I%, $(MODULES))

# Make sure the entire build depends on all makefile fragments.
# MAKEFILES := project.mk $(addsuffix /module.mk, $(MODULES))


# These are bodies of build rules.  Note that these variables _need_
# delayed evaluation, as the $@ and $< variables are filled in when
# the rule is applied.

# build = @echo "$@"; $(1)
build = $(1)


# .c deps are created using gcc -M, ignoring generated files (-MG) and
# explicity prefixing the output rule with the directory of the
# object.

rule_d_c = $(call build, (echo -n $(dir $<); $(CC) -M -MG $(CPPFLAGS) $<) >$@)
rule_o_c = $(call build, $(CC) $(CPPFLAGS) $(CFLAGS) $(OPTI_CFLAGS) $(DEBUG_CFLAGS) -o $@ -c $<)
rule_h_prims_c = $(call build, $(MZSCHEME) $(dir $<)gen_prims.ss $< >$@)
rule_h_pf_prims_c = $(call build, $(MZSCHEME) $(dir $<)pf_prims.ss $< >$@)

%.d: %.c $(MAKEFILES)
	$(rule_d_c)

%.o: %.c $(MAKEFILES)
	$(rule_o_c)

# Generated header files.  These assume the .c file's directory
# contains the `gen_prims.ss' script.
%.h_prims: %.c
	$(rule_h_prims_c)

%.h_pf_prims: %.c
	$(rule_h_pf_prims_c)



# This function generates a makefile fragment that gathers variables
# and build rules through an include, and accumulates them to global
# variables.
define module
MODULE := $(1) 	# Define module name for use in included fragment
include $(1)/module.mk

# Get properly prefixed list of sources and objects.
$(1)_SRC := $$(addprefix $(1)/, $$(SRC))
$(1)_OBJ := $$($(1)_SRC:.c=.o)
DEPS := $$(DEPS) $$($(1)_SRC:.c=.d)

# Build a single archive per module.
$(1)/$(1).a: $$($(1)_OBJ)
	@echo "$$@"
	@ar rcs $$@ $$($(1)_OBJ)
PROJECT_A := $$(PROJECT_A) $(1)/$(1).a
# Clear local vars.
SRC :=
MODULE :=
endef

# Expand template for each module
$(foreach prog,$(MODULES),$(eval $(call module,$(prog))))

# Include generated dependencies.
-include $(DEPS)


# Products: app <target> <deps> <libs>
define app
$(1): $(2)
	@echo $(1)
	@$$(CC) $$(LDFLAGS) -o $(1) $(2) $(3)
endef

# Expand template for each app
$(eval $(call app, sc/sc, sc/sc.a ex/ex.a leaf/leaf.a, -lm -lpthread))
$(eval $(call app, pf/pf, pf/pf.a ex/ex.a leaf/leaf.a, -lm -lpthread))


.PHONY: all clean

# OBJECTS := $(PROJECT_SRC:.c=.o)
OBJECTS := $(PROJECT_A)

_all: $(OBJECTS)

